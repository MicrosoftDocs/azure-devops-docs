---
title: Deploy to Azure Kubernetes Service
description: Build and push images to Azure Container Registry; Deploy to Azure Kubernetes Service
ms.prod: devops
ms.technology: devops-cicd
ms.topic: tutorial
ms.assetid: cdf9ed1b-6986-43c3-8270-5d7d31c1ddf1
ms.manager: jillfra
ms.author: shasb
author: shashankbarsin
ms.date: 08/30/2019
monikerRange: 'azure-devops'
---

# Build and deploy to Azure Kubernetes Service

[!INCLUDE [include](../../_shared/version-team-services.md)]

 Azure Kubernetes Service manages your hosted Kubernetes environment, making it quicker and easier for you to deploy and manage containerized applications. This service also eliminates the burden of ongoing operations and maintenance by provisioning, upgrading, and scaling resources on demand, without taking your applications offline.

In this step-by-step guide, you'll learn how to create a pipeline that continuously builds and deploys your app. Every time you change your code in a repository that contains a Dockerfile, the images are pushed to your Azure Container Registry, and the manifests are then deployed to your Azure Kubernetes Service cluster.

## Prerequisites

[!INCLUDE [include](../../_shared/prerequisites.md)]

[!INCLUDE [include](../../_shared/azure-prerequisites.md)]

## Get the code

Based on the desired runtime, [import](../../../repos/git/import-git-repository.md) (into Azure DevOps) or fork (into GitHub) the following repository

#### [Java](#tab/java)

[!INCLUDE [include](../_shared/get-code-before-sample-repo-option-to-use-own-code.md)]

```
https://github.com/spring-guides/gs-spring-boot-docker.git
```
#### [JavaScript](#tab/java-script)

[!INCLUDE [include](../_shared/get-code-before-sample-repo-option-to-use-own-code.md)]

```
https://github.com/MicrosoftDocs/pipelines-javascript-docker
```
#### [Python](#tab/python)

[!INCLUDE [include](../_shared/get-code-before-sample-repo-option-to-use-own-code.md)]

```
https://github.com/Microsoft/python-sample-vscode-flask-tutorial/
```
#### [.NET Core](#tab/dotnet-core)

[!INCLUDE [include](../_shared/get-code-before-sample-repo-option-to-use-own-code.md)]

```
https://github.com/MicrosoftDocs/pipelines-dotnet-core-docker
```

* * *

## Create the Azure resources

[!INCLUDE [include](../_shared/sign-in-azure-cli.md)]

### Create a container registry

```azurecli-interactive
# Create a resource group
az group create --name myapp-rg --location eastus

# Create a container registry
az acr create --resource-group myapp-rg --name myContainerRegistry --sku Basic

# Create a Kubernetes cluster
az aks create \
    --resource-group myapp-rg \
    --name myapp \
    --node-count 1 \
    --enable-addons monitoring \
    --generate-ssh-keys
```

## Sign in to Azure Pipelines
[!INCLUDE [include](../_shared/sign-in-azure-pipelines.md)]

[!INCLUDE [include](../_shared/create-project.md)]


## Create the pipeline
### Connect and select repository
[!INCLUDE [include](../_shared/create-pipeline-before-template-selected.md)]

When the **Configure** tab appears, select **Deploy to Azure Kubernetes Service**. 

1. If you are prompted, select the subscription in which you created your registry and cluster.

2. Select the `myapp` cluster.

3. For **Namespace**, select **Existing**, and then select **default**.

4. Select the name of your container registry.

5. You can leave the image name and the service port set to the defaults.

6. Select **Validate and configure**.

   As Azure Pipelines creates your pipeline, it:

   * Creates a _Docker registry service connection_ to enable your pipeline to push images into your container registry.

   * Creates an _environment_ and a Kubernetes resource within the environment. For an RBAC enabled cluster, the created Kubernetes resource implicitly creates ServiceAccount and RoleBinding objects in the cluster so that the created ServiceAccount can't perform operations outside the chosen namespace.

   * Generates an *azure-pipelines.yml* file, which defines your pipeline.

   * Generates Kubernetes manifest files. These files are generated by hydrating the [deployment.yml](https://github.com/Microsoft/azure-pipelines-yaml/blob/master/templates/resources/k8s/deployment.yml) and [service.yml](https://github.com/Microsoft/azure-pipelines-yaml/blob/master/templates/resources/k8s/service.yml) templates based on selections you made above.

7. When your new pipeline appears, take a look at the YAML to see what it does (for more information, see [How we build your pipeline](#how) below). When you're ready, select **Save and run**.

8. The commit that will create your new pipeline appears. You can see the generated files mentioned above. Select **Save and run**.

9. If you want, change the **Commit message** to something like _Add pipeline to our repository_. When you're ready, select **Save and run** to commit the new pipeline into your repo, and then begin the first run of your new pipeline!

## See the pipeline run, and your app deployed

As your pipeline runs, watch as your build stage, and then your deployment stage, go from blue (running) to green (completed). You can select the stages and jobs to watch your pipeline in action.

After the pipeline run is finished, explore what happened and then go see your app deployed. From the pipeline summary:

1. Select the **Environments** tab.

1. Select **View environment**.

1. Select the instance if your app for the namespace you deployed to. If you stuck to the defaults we mentioned above, then it will be the **myapp** app in the **default** namespace.

1. Select the **Services** tab.

1. Select and copy the external IP address to your clipboard.

1. Open a new browser tab or window and enter &lt;IP address&gt;:8080.

If you're building our sample app, then _Hello world_ appears in your browser.

<a name="how"></a>
## How we build your pipeline

When you finished selecting options and then proceeded to validate and configure the pipeline (see above) Azure Pipelines created a pipeline for you, using the _Deploy to Azure Kubernetes Service_ template.

The build stage uses the [Docker task](../../tasks/build/docker.md) to build and push the image to the Azure Container Registry.

```YAML
- stage: Build
  displayName: Build stage
  jobs:  
  - job: Build
    displayName: Build job
    pool:
      vmImage: $(vmImageName)
    steps:
    - task: Docker@2
      displayName: Build and push an image to container registry
      inputs:
        command: buildAndPush
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(dockerRegistryServiceConnection)
        tags: |
          $(tag)
          
    - task: PublishPipelineArtifact@1
      inputs:
        artifactName: 'manifests'
        path: 'manifests'
```

The deployment job uses the _Kubernetes manifest task_ to create the `imagePullSecret` required by Kubernetes cluster nodes to pull from the Azure Container Registry resource. Manifest files are then used by the Kubernetes manifest task to deploy to the Kubernetes cluster.

```YAML
- stage: Deploy
  displayName: Deploy stage
  dependsOn: Build
  jobs:
  - deployment: Deploy
    displayName: Deploy job
    pool:
      vmImage: $(vmImageName)
    environment: 'shashankbarsinpipelinesjavascriptdocker.aksnamespace'
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            inputs:
              artifactName: 'manifests'
              downloadPath: '$(System.ArtifactsDirectory)/manifests'

          - task: KubernetesManifest@0
            displayName: Create imagePullSecret
            inputs:
              action: createSecret
              secretName: $(imagePullSecret)
              namespace: $(k8sNamespace)
              dockerRegistryEndpoint: $(dockerRegistryServiceConnection)
              
          - task: KubernetesManifest@0
            displayName: Deploy to Kubernetes cluster
            inputs:
              action: deploy
              namespace: $(k8sNamespace)
              manifests: |
                $(System.ArtifactsDirectory)/manifests/deployment.yml
                $(System.ArtifactsDirectory)/manifests/service.yml
              imagePullSecrets: |
                $(imagePullSecret)
              containers: |
                $(containerRegistry)/$(imageRepository):$(tag)
```


[!INCLUDE [include](../_shared/clean-up-resources.md)]

```azurecli-interactive
az group delete --name MC_myapp-rg_myapp_eastus
```
Type `y` when prompted.

## Learn more

We invite you to learn more about:
* The services:
  - [Azure Kubernetes Service](https://azure.microsoft.com/services/kubernetes-service/)
  - [Azure Container Registry](https://azure.microsoft.com/services/container-registry/)
* The template used to create your pipeline: [Deploy to existing Kubernetes cluster template](https://github.com/Microsoft/azure-pipelines-yaml/blob/master/templates/deploy-to-existing-kubernetes-cluster.yml)
* Some of the tasks used in your pipeline, and how you can customize them:
 - [Docker task](../../tasks/build/docker.md)
 - [Kubernetes manifest task](../../tasks/deploy/kubernetes-manifest.md)
* Some of the key concepts for this kind of pipeline:
  - [Environments](../../process/environments.md)
  - [Deployment jobs](../../process/deployment-jobs.md)
  - [Stages](../../process/stages.md)
  - [Docker registry service connections](../../library/service-endpoints.md#sep-docreg) (the method your pipeline uses to connect to the service)
